#!/bin/bash

# Exit codes
exit_success=0
exit_missing_mdfile=255
exit_missing_entry=254
exit_bad_pandoc=252
exit_bad_outdir=250
exit_bad_viewer=248
exit_bad_config=247

progname=$(basename $0)
version="0.2.0"

# Default configuration path
config_path="~/.config/${progname}.conf"

print_help()
{
	echo "$progname $version: Render a document with Pandoc"

	echo ""
	print_entries "${config_path}"
	echo ""

	cat <<- EOF
	Usage: $progname [OPTIONS] input

	OPTIONS
	  -c PATH   Path to configuration file (default: ${config_path})
	  -e ENTRY  One of the entries listed above
	  -h	    Print usage and exit
	  -o FILE   Path of output file (default: save file to cwd with configured
	            extension)
	  -p	    Toggle preview (default: true in watch mode, false otherwise)
	  -v        Print version and exit
	  -V	    Verbose: includes echoing Pandoc commands
	  -w        Enable watch mode
	EOF
}

print_entries()
{
	# Expand tilde to HOME if it's in the path
	local infile=${1/#\~/$HOME}
	local line section name

	if [ ! -f "${infile}" ]; then
		echo "[Config file not found at ${config_path}]"
		return
	fi

	echo "ENTRIES"

	while IFS= read -r line; do
		# Ignore comment lines
		if [[ "$line" =~ ^[[:space:]]*\# ]]; then
			continue
		fi

		# [section]
		if [[ "$line" =~ ^[[:space:]]*\[(.*)\][[:space:]]*$ ]]; then
			if [[ -z ${value+x} ]] && [[ -n "$section" ]] &&
			[[ $section != "main" ]]; then
				# If we were in an entry section (not "main") that didn't have
				# a description, print something to indicate that.
				echo "  - ${section}: (No description given)"
			fi
			section="${BASH_REMATCH[1]}"
			continue
		fi

		# This line is relevant to the section. Process it.
		if [[ $line =~ ^[[:space:]]*desc[[:space:]]*=[[:space:]]*(.*)$ ]]; then
			value=${BASH_REMATCH[1]}
			echo "  - ${section}: ${value}"
		fi

		# Check for a default entry
		if [[ $line =~ ^[[:space:]]*default[[:space:]]*=[[:space:]]*(.*)$ ]]; then
			default=${BASH_REMATCH[1]}
		fi
	done < ${infile}

	if [[ -v default ]]; then
		echo ""
		echo "Default: ${default}"
	fi
}

## This function was adapted from a Reddit comment:
## https://www.reddit.com/r/bash/comments/s6crjo/comment/ht3vrh1
read_config()
{
	# Expand tilde to HOME if it's in the path
	local infile=${1/#\~/$HOME}
	local section=$2
	local in_section=0
	local line name value

	while IFS= read -r line; do
		# Ignore comment lines
		if [[ "$line" =~ ^[[:space:]]*\# ]]; then
			continue
		fi

		# [section]
		if [[ "$line" =~ ^[[:space:]]*\[(.*)\][[:space:]]*$ ]]; then
			[[ "${BASH_REMATCH[1]}" == "$section" ]] && in_section=1 || in_section=0
			continue
		fi

		# If this was not a section marker, and we are not in the section of
		# interest, skip this line
		if ((!in_section)); then
			continue
		fi

		# This line is relevant to the section. Process it.
		if [[ $line =~ ^[[:space:]]*$ ]]; then
			# Ignore empty line
			# echo "E"
			continue
		elif [[ $line =~ ^[[:space:]]+(.*)$ ]]; then
			# Continuation of a previous line starts with indentation.
			# Use the same key from the last step and append the new material.
			# echo "C : $line"
			config[$name]="${config[$name]}$line"
		elif [[ $line =~ ^[[:space:]]*([^=]*)=[[:space:]]*(.*)$ ]]; then
			# New configuration item. Strip trailing whitespace from name
			name=${BASH_REMATCH[1]}
			name="${name%"${name##*[![:space:]]}"}"
			value=${BASH_REMATCH[2]}
			# echo "N : $name => $value"
			config[$name]="$value"
		fi
	done < ${infile}

	# If config array is still empty, the entry was not found
	if [ ${#config[@]} -eq 0 ]; then
		echo "Entry '${section}' not found"
		exit $exit_missing_entry
	fi
}

render()
{
	local mdpath=$1
	local outfile=$2
	local pandoc_flags=$3
	local verbose=$4

	local cmd="pandoc ${mdpath} ${pandoc_flags} -o ${outfile}"

	# Echo the pandoc command if verbose option was enabled
	if [ $verbose == "true" ]; then
		echo $cmd
	fi

	eval $cmd || {
		exit ${exit_bad_pandoc}
	}

	# Output: outfile
}

preview()
{
	local infile=$1
	local viewer_cmd=$2
	local verbose=$3

	# Replace '%s' placeholder with filename
	viewer_cmd=${viewer_cmd//%s/$infile}

	# If not verbose, capture viewer output to /dev/null
	if [ $verbose == "false" ]; then
		viewer_cmd="${viewer_cmd} > /dev/null 2>&1"
	fi

	# Viewer should run as a detached process
	viewer_cmd="nohup ${viewer_cmd} &"

	eval ${viewer_cmd} || {
		echo "Viewer command failed: ${viewer_cmd}"
		exit ${exit_bad_viewer}
	}
}

#-----------------------------
# ----- Begin processing -----
#-----------------------------
preview_toggle=false
verbose=false
watch_mode=false

# ----- Get command line arguments -----

# Get the options
while getopts "he:po:t:c:wVv" option; do
	case $option in
		h)
			print_help
			exit ${exit_success}
			;;
		c)
			config_path=${OPTARG}
			;;
		e)
			entry=${OPTARG}
			;;
		o)
			outfile=${OPTARG}
			;;
		p)
			preview_toggle=true
			;;
		w)
			watch_mode=true
			;;
		V)
			verbose=true
			;;
		v)
			echo $version
			exit ${exit_success}
			;;
	esac
done

# Remaining argument should be the name of the markdown file for input
shift $(($OPTIND - 1))
mdfile=$1

if [ -z "$mdfile" ]; then
	echo "No input file specified"
	exit ${exit_missing_mdfile}
fi

# Expand to absolute path
mdpath=$(realpath $mdfile)

# ----- Load configuration -----
# Read main config section and copy elements to array config_main
declare -A config=()
read_config ${config_path} "main"

declare -A config_main
for key in "${!config[@]}"; do
	config_main["$key"]="${config[$key]}"
done

# Check for default entry in config if not specified on CLI
if [ -z "$entry" ]; then
	if [ "${config_main["default"]}" != "" ]; then
		entry=${config_main["default"]}
	else
		echo "No entry specified and no default set"
		exit ${exit_missing_entry}
	fi
fi

# Read entry config section and copy elements to array config_entry
declare -A config=()
read_config ${config_path} ${entry}

declare -A config_entry
for key in "${!config[@]}"; do
	config_entry["$key"]="${config[$key]}"
done

# Try to avoid error checking on these until/unless they are needed
dest_ext=${config_entry["ext"]}
pandoc_flags="${config_main["flags"]} ${config_entry["flags"]}"
interval_peek=${config_main["peek"]}
interval_rest=${config_main["rest"]}
viewer_cmd=${config_entry["view"]}

# ----- Output filename -----
# Name the output file if not specified as an argument
if [ ! -v outfile ]; then
	if [ "$dest_ext" == "" ]; then
		echo "${config_path}: 'ext' not found for '${entry}' entry"
		exit ${exit_bad_config}
	fi

	base=$(basename $mdpath)
	src_ext=${base##*.}

	if [ $base != $src_ext ]; then
		# replace extension of input file with $dest_ext
		outfile=${PWD}/${base%$src_ext}${dest_ext}
	else
		# there was no extension on input file, so add a ".pdf" to the output
		outfile=${PWD}/${base}.${dest_ext}
	fi
fi

# ----- Render -----
# Change to dirname of the input file so we can use its relative path to find
# bibliography and any other resouces.

cd $(dirname $mdpath)
render "${mdpath}" "${outfile}" "${pandoc_flags}" "${verbose}"

# ----- Preview -----
# Set preview mode based on watch interval and toggle it if requested
[[ $watch_mode == "true" ]] && preview_mode=true || preview_mode=false

if [[ $preview_toggle == "true" ]]; then
	[[ $preview_mode == "true" ]] && preview_mode=false || preview_mode=true
fi

if [ "$viewer_cmd" == "" ]; then
	echo "${config_path}: 'view' not found for '${entry}' entry"
	exit ${exit_bad_config}
fi

# Open previewer if the option was given.
if [ $preview_mode == "true" ]; then
	preview "${outfile}" "${viewer_cmd}" "${verbose}"
fi

# ----- Watch for changes -----
if [ $watch_mode == "false" ]; then
	exit ${exit_success}
fi

if [ "$interval_peek" == "" ]; then
	echo "${config_path}: 'peek' not found in 'main'"
	exit ${exit_bad_config}
fi

if [ "$interval_rest" == "" ]; then
	echo "${config_path}: 'rest' not found in 'main'"
	exit ${exit_bad_config}
fi

mod_prev="$(stat -c "%Y" "${mdpath}")"
while true; do
	sleep "$interval_peek"
	mod_time="$(stat -c "%Y" "${mdpath}")"

	if [[ "$mod_time" != "$mod_prev" ]]; then
		[[ $verbose == "true" ]] && echo "${mdfile} was modified ${mod_time}"
		render "${mdpath}" "${outfile}" "${pandoc_flags}" "${verbose}"
		mod_prev="$mod_time"
		sleep "$interval_rest"
	else
		[[ $verbose == "true" ]] && echo "${mdfile} not modified"
	fi
done

